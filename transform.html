<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GSLAM: 3D Transformations: SO3, SE3, SIM3</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logosmall.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GSLAM
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">3D Transformations: SO3, SE3, SIM3 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>GSLAM implemented some high performance transformation classes in headers without other dependencies.</p>
<p>The below table is a comparison with other three popular c++ transform implementations. The table statistics time usages for looping 1M times of transform multiply, point transform, exponential and logarithm in milli-seconds on an i7-6700 CPU running 64bit Ubuntu.</p>
<table class="doxtable">
<tr>
<th>Function </th><th>GSLAM </th><th>Sophus </th><th>TooN </th><th>Ceres  </th></tr>
<tr>
<td>SO3::mult </td><td><b> 14.9 </b> </td><td>34.3 </td><td>17.8 </td><td>159.1 </td></tr>
<tr>
<td>SO3::trans </td><td>15.4 </td><td>17.2 </td><td><b> 14.5 </b></td><td>90.4 </td></tr>
<tr>
<td>SO3::exp </td><td><b> 80.7 </b> </td><td>98.4 </td><td>106.8 </td><td>- </td></tr>
<tr>
<td>SO3::log </td><td><b> 55.7 </b> </td><td>72.5 </td><td>63.8 </td><td>- </td></tr>
<tr>
<td>SE3::mult </td><td><b> 28.6 </b> </td><td>55.2 </td><td>29.3 </td><td>- </td></tr>
<tr>
<td>SE3::trans </td><td>19.3 </td><td>19.8 </td><td><b>12.1 </b> </td><td>- </td></tr>
<tr>
<td>SE3::exp </td><td>152.4 </td><td>19. 8 </td><td><b>99.2 </b> </td><td>- </td></tr>
<tr>
<td>SE3::log </td><td><b> 152.7 </b> </td><td>194.0 </td><td>205.8 </td><td>- </td></tr>
<tr>
<td>SIM3::mult </td><td><b> 33.2 </b> </td><td>58.5 </td><td>34.5 </td><td>- </td></tr>
<tr>
<td>SIM3::trans </td><td>16.9 </td><td>17.2 </td><td><b>13.7 </b> </td><td>- </td></tr>
<tr>
<td>SIM3::exp </td><td><b> 180.2 </b> </td><td>286.8 </td><td>229.0 </td><td>- </td></tr>
<tr>
<td>SIM3::log </td><td><b> 202.5 </b> </td><td>341.6 </td><td>303.6 </td><td>- </td></tr>
</table>
<h1><a class="anchor" id="sSO3"></a>
SO3: 3D rotation represented by the quaternion.</h1>
<h2><a class="anchor" id="sSO3_intro"></a>
Introduction</h2>
<p>For the rotational component, there are several choices for representation, including the matrix, Euler angle, unit quaternion and Lie algebra \(so(3)\). For a given transformation, we can use any of these for representation and can convert one to another.:</p><ul>
<li>An unit orthogonal 3x3 matrix \( \mathbf{R} \).</li>
<li>The Euler angle representation uses 3 variables such as yaw, roll, pitch.</li>
<li>Quaternion \(q(x,y,z,w)\): the most efficient way to perform multiple.</li>
<li>Lie algebra \([a,b,c]\): the common representation to perform manifold optimization.</li>
</ul>
<p>This implementation use Quaternion for computation. Class SO3 use 4 paraments to present a 3 dimesion rotation matrix, since 3D rotation matrices are members of the Special Orthogonal Lie group SO3.</p>
<p>Every rotation in the 3D euclidean space can be represented by a rotation with one direction. Consider a rotation with direction \((a,b,c)^T\) and angle theta in radians.</p><ul>
<li>w &ndash; \(cos(theta/2)\)</li>
<li>x &ndash; \(a*sin(theta/2)\)</li>
<li>y &ndash; \(b*sin(theta/2)\)</li>
<li>z &ndash; \(c*sin(theta/2)\)</li>
</ul>
<p>this ensures that \(x^2+y^2+z^2+w^2=1\). A quaternion \(q(x,y,z,w)\) is used to present a 3d rotation.</p>
<h2><a class="anchor" id="Constructors"></a>
Constructors</h2>
<p>Users can construct a SO3 from different data structure: </p><div class="fragment"><div class="line">SO3 I;<span class="comment">// default, idendity</span></div><div class="line">SO3 R1(x,y,z,w);<span class="comment">// from quaternion</span></div><div class="line">SO3 R2(Poin3d(rx,ry,rz),angle)<span class="comment">// from axis and angle</span></div><div class="line">SO3 R3=SO3::exp(Point3d(rx,ry,rz));<span class="comment">// from lie algebra</span></div><div class="line">SO3 R4=SO3(Matrix3d(m));<span class="comment">// from matrix</span></div><div class="line">SO3 R4=SO3(m);<span class="comment">// from pointer</span></div><div class="line">SO3 R5=SO3::fromPitchYawRoll(pitch,yaw,roll); <span class="comment">// from Euler</span></div></div><!-- fragment --><h2><a class="anchor" id="sSO3_usage"></a>
Usages</h2>
<p>The following testing codes demonstrated the basic usages of SO3:</p>
<div class="fragment"><div class="line">std::default_random_engine e;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> pitch=std::uniform_real_distribution&lt;double&gt;(-M_PI/2,M_PI/2)(e);</div><div class="line"><span class="keywordtype">double</span> yaw  =std::uniform_real_distribution&lt;double&gt;(-M_PI,M_PI)(e);</div><div class="line"><span class="keywordtype">double</span> roll =std::uniform_real_distribution&lt;double&gt;(-M_PI/2,M_PI/2)(e);</div><div class="line"></div><div class="line">SO3 q=SO3::fromPitchYawRoll(pitch,yaw,roll);</div><div class="line"></div><div class="line">EXPECT_NEAR(pitch,q.getPitch(),1e-5);</div><div class="line">EXPECT_NEAR(yaw,q.getYaw(),1e-5);</div><div class="line">EXPECT_NEAR(roll,q.getRoll(),1e-5);</div><div class="line"></div><div class="line"><span class="comment">// X: forward Y: right Z: down</span></div><div class="line">SO3 qRoll =SO3::exp(Point3d(roll,0,0));</div><div class="line">SO3 qPitch=SO3::exp(Point3d(0,pitch,0));</div><div class="line">SO3 qYaw  =SO3::exp(Point3d(0,0,yaw));</div><div class="line"></div><div class="line">SO3 q1=qYaw*qPitch*qRoll;</div><div class="line">EXPECT_EQ(q,q1);</div><div class="line"></div><div class="line">Matrix3d m=q.getMatrix();</div><div class="line">q1=SO3(m);</div><div class="line">EXPECT_EQ(q,q1);</div><div class="line"></div><div class="line">Point3d abc=q.log();</div><div class="line">q1=SO3::exp(abc);</div><div class="line">EXPECT_EQ(q,q1);</div><div class="line">EXPECT_EQ(SO3(),q.inv()*q);</div><div class="line"></div><div class="line">std::uniform_real_distribution&lt;double&gt; pt_gen(-1000,1000);</div><div class="line">Point3d xyz(pt_gen(e),pt_gen(e),pt_gen(e));</div><div class="line">Point3d p1=q.inv()*q*xyz;</div><div class="line">EXPECT_NEAR((xyz-p1).norm(),0,1e-6);</div></div><!-- fragment --><h1><a class="anchor" id="sSE3"></a>
SE3: 3D Rigid Transformation.</h1>
<p>A 3D rigid transformation can be presented with an special 3D Homography matrix \(\mathbf{T}\) constructed with translation \(t\) and rotation \(R\).</p>
<p>\( \mathbf{T} = \left[\begin{array}{cc}\mathbf{R}&amp; \mathbf{t} \\ \mathbf{0}^T&amp; 1 \end{array} \right]= \left[\begin{array}{cccc}rx_x &amp; ry_x &amp; rz_x &amp; x \\ rx_y &amp; ry_y &amp; rz_y &amp; y\\ rx_z &amp; ry_z &amp; rz_z &amp; z\\ 0&amp;0&amp;0&amp; 1\end{array} \right]. \)</p>
<p>Here \(\mathbf{R}=(\mathbf{rx},\mathbf{ry},\mathbf{rz})\) is the rotation , \(\mathbf{t}=(x,y,z)^T\) is the translation.</p>
<p>When matrix \(T\) means a camera to world transform:</p><ul>
<li>\(\mathbf{rx}\) means the direction of X axis;</li>
<li>\(\mathbf{ry}\) means the direction of Y axis;</li>
<li>\(\mathbf{rz}\) means the direction of Z axis;</li>
<li>\(\mathbf{t}\) means the translation of this coordinate.</li>
</ul>
<p>Here below is little test example with some usages demo: </p><div class="fragment"><div class="line">TEST(Transform,SE3){</div><div class="line">    std::default_random_engine e;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> pitch=std::uniform_real_distribution&lt;double&gt;(-M_PI/2,M_PI/2)(e);</div><div class="line">    <span class="keywordtype">double</span> yaw  =std::uniform_real_distribution&lt;double&gt;(-M_PI,M_PI)(e);</div><div class="line">    <span class="keywordtype">double</span> roll =std::uniform_real_distribution&lt;double&gt;(-M_PI/2,M_PI/2)(e);</div><div class="line">    std::uniform_real_distribution&lt;double&gt; pt_gen(-1000,1000);</div><div class="line"></div><div class="line">    SE3 T(SO3::fromPitchYawRoll(pitch,yaw,roll),</div><div class="line">          Point3d(pt_gen(e),pt_gen(e),pt_gen(e)));</div><div class="line"></div><div class="line">    Point3d pt(pt_gen(e),pt_gen(e),pt_gen(e));</div><div class="line"></div><div class="line">    Point3d error=T*pt-T.get_translation()-T.get_rotation()*pt;</div><div class="line">    EXPECT_NEAR(error.norm(),0,1e-8);</div><div class="line"></div><div class="line">    SE3 T1=T.inverse()*T;</div><div class="line">    EXPECT_NEAR(T1.get_translation().norm(),0,1e-8);</div><div class="line">    EXPECT_EQ(T1.get_rotation(),SO3());</div><div class="line"></div><div class="line">    Vector6d se3=T.log();</div><div class="line">    SE3 T2=T.inverse()*SE3::exp(se3);</div><div class="line">    EXPECT_NEAR(T2.get_translation().norm(),0,1e-8);</div><div class="line">    EXPECT_EQ(T2.get_rotation(),SO3());</div><div class="line">}</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>It should be noticed that when a SE3 is representing the world-to-camera transform, the function <code>get_translation()</code> does not acqually return the translation.</dd></dl>
<h1><a class="anchor" id="sSIM3"></a>
SIM3: 3D similarity transformation</h1>
<p>A SIM3 is the equivalent of a 4*4 Matrix \(S\):</p>
<p>\( \mathbf{S} = \left[\begin{array}{cc}s\mathbf{R}&amp; \mathbf{t} \\ \mathbf{0}^T&amp; 1 \end{array} \right]. \)</p>
<ul>
<li>\(\mathbf{R}\): Rotation &ndash; 3dof</li>
<li>\(\mathbf{t}\): Translation &ndash; 3dof</li>
<li>s: scale &ndash;1dof</li>
</ul>
<p>The following testing example demostrated some basic usages of SIM3. </p><div class="fragment"><div class="line">TEST(Transform,SIM3){</div><div class="line">    std::default_random_engine e;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> pitch=std::uniform_real_distribution&lt;double&gt;(-M_PI/2,M_PI/2)(e);</div><div class="line">    <span class="keywordtype">double</span> yaw  =std::uniform_real_distribution&lt;double&gt;(-M_PI,M_PI)(e);</div><div class="line">    <span class="keywordtype">double</span> roll =std::uniform_real_distribution&lt;double&gt;(-M_PI/2,M_PI/2)(e);</div><div class="line">    std::uniform_real_distribution&lt;double&gt; pt_gen(-1000,1000);</div><div class="line"></div><div class="line">    SIM3 S(SO3::fromPitchYawRoll(pitch,yaw,roll),</div><div class="line">          Point3d(pt_gen(e),pt_gen(e),pt_gen(e)),</div><div class="line">          100);</div><div class="line">    SIM3 S1=SIM3::exp(S.log());</div><div class="line">    EXPECT_EQ(S.get_rotation(),S1.get_rotation());</div><div class="line">    EXPECT_NEAR((S.get_translation()-S1.get_translation()).norm(),0,1e-6);</div><div class="line">    EXPECT_NEAR(S.get_scale(),S1.get_scale(),1e-6);</div><div class="line"></div><div class="line">    SIM3 SS=S*S1;</div><div class="line">    Point3d pt(pt_gen(e),pt_gen(e),pt_gen(e));</div><div class="line"></div><div class="line">    Point3d diff=S*S1*pt-SS*pt;</div><div class="line">    EXPECT_NEAR(diff.norm(),0,1e-10);</div><div class="line"></div><div class="line">    SIM3 ST=S*S1.get_se3();</div><div class="line">    EXPECT_EQ(S.get_scale(),ST.get_scale());</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
